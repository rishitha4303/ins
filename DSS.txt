import randomdef mod_inverse(a, m):return pow(a, -1, m)def hash_msg(msg, q):return sum(ord(c)*(i+1) for i, c in enumerate(msg)) % qdef sign(msg, p, q, g, x):h = hash_msg(msg, q)while True:k = random.randint(1, q-1)r = pow(g, k, p) % qif not r:continues = (mod_inverse(k, q) * (h + x*r)) % qif s:return s, rdef verify(msg, s, r, p, q, g, y):if not (0 < r < q and 0 < s < q):return Falseh = hash_msg(msg, q)w = mod_inverse(s, q)v = (pow(g, hw % q, p) * pow(y, rw % q, p)) % qreturn v == rp, q, g = 23, 11, 4x = 6 # private keyy = pow(g, x, p) # public keymsg = input("Enter a msg:")s, r = sign(msg, p, q, g, x)print(f"Message: {msg}\nSignature: (s={s}, r={r})")print("Verified:", verify(msg, s, r, p, q, g, y))tampered = input("Enter a tampered msg:")print(f"\nTampered: {tampered}")print("Verified:", verify(tampered, s, r, p, q, g, y))